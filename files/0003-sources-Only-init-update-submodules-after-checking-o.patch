From 968090fe139bb6d8cb20da42696a593f800c0636 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey@solus-project.com>
Date: Sun, 30 Oct 2016 15:32:45 +0000
Subject: [PATCH 3/4] sources: Only init + update submodules *after* checking
 out new ref

Previously we would recursively clone, then check out the tag after having
all of our submodules present, causing a dirty tree, and builds to fail.
Now we do things in a sensible order.

Signed-off-by: Ikey Doherty <ikey@solus-project.com>
---
 ypkg2/sources.py | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/ypkg2/sources.py b/ypkg2/sources.py
index 6a4642c..133cf75 100644
--- a/ypkg2/sources.py
+++ b/ypkg2/sources.py
@@ -105,7 +105,7 @@ class GitSource(YpkgSource):
                                       "directory: {}".format(e))
                 return False
 
-        cmd = "git -C \"{}\" clone --recursive \"{}\" {}".format(
+        cmd = "git -C \"{}\" clone \"{}\" {}".format(
             source_dir, self.uri, self.get_target_name())
 
         console_ui.emit_info("Git", "Fetching: {}".format(self.uri))
@@ -127,6 +127,21 @@ class GitSource(YpkgSource):
             console_ui.emit_error("Git", "Failed to checkout {}".format(
                                   self.tag))
             return False
+
+        ddir = os.path.join(source_dir, self.get_target_name())
+        if not os.path.exists(os.path.join(ddir, ".gitmodules")):
+            return True
+
+        cmd1 = "git -C \"{}\" submodule init".format(ddir)
+        cmd2 = "git -C \"{}\" submodule update".format(ddir)
+
+        try:
+            r = subprocess.check_call(cmd1, shell=True)
+            r = subprocess.check_call(cmd2, shell=True)
+        except Exception as e:
+            console_ui.emit_error("Git", "Failed to submodule init {}".format(
+                                  e))
+            return False
         return True
 
     def verify(self, context):
-- 
2.10.1

